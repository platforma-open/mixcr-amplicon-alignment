ll := import("@platforma-sdk/workflow-tengo:ll")
self := import("@platforma-sdk/workflow-tengo:tpl.light")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")
smart := import("@platforma-sdk/workflow-tengo:smart")
slices := import("@platforma-sdk/workflow-tengo:slices")
assets := import("@platforma-sdk/workflow-tengo:assets")
exec := import("@platforma-sdk/workflow-tengo:exec")
pt := import("@platforma-sdk/workflow-tengo:pt")
clonotypeLabel := import(":clonotype-label")

json := import("json")
text := import("text")

mixcrSw := assets.importSoftware("@platforma-open/milaboratories.software-mixcr:memory-from-limits")

self.defineOutputs("tsv")

applyStopCodonReplacementsPt := func(df, opts) {
	if is_undefined(opts) {
		return df
	}
	aminoAcidSeqColumns := opts.aminoAcidSeqColumns
	cdr3SeqColumns := opts.cdr3SeqColumns
	stopCodonTypes := opts.stopCodonTypes
	stopCodonReplacements := opts.stopCodonReplacements

	if is_undefined(aminoAcidSeqColumns) || len(aminoAcidSeqColumns) == 0 {
		return df
	}
	if is_undefined(stopCodonTypes) || !is_array(stopCodonTypes) || len(stopCodonTypes) == 0 {
		return df
	}
	if !is_undefined(stopCodonReplacements) && !is_map(stopCodonReplacements) {
		stopCodonReplacements = undefined
	}

	contains := func(arr, value) {
		for v in arr {
			if v == value { return true }
		}
		return false
	}

	stopReplacement := func(stopType) {
		if !contains(stopCodonTypes, stopType) {
			return "*"
		}
		if is_undefined(stopCodonReplacements) {
			return "*"
		}
		aa := stopCodonReplacements[stopType]
		if is_undefined(aa) || aa == "" {
			return "*"
		}
		return text.to_upper(aa)
	}

	codonMapBase := {
		"TTT": "F", "TTC": "F", "TTA": "L", "TTG": "L",
		"TCT": "S", "TCC": "S", "TCA": "S", "TCG": "S",
		"TAT": "Y", "TAC": "Y", "TAA": "*",
		"TAG": "*", "TGT": "C", "TGC": "C",
		"TGA": "*", "TGG": "W",
		"CTT": "L", "CTC": "L", "CTA": "L", "CTG": "L",
		"CCT": "P", "CCC": "P", "CCA": "P", "CCG": "P",
		"CAT": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
		"CGT": "R", "CGC": "R", "CGA": "R", "CGG": "R",
		"ATT": "I", "ATC": "I", "ATA": "I", "ATG": "M",
		"ACT": "T", "ACC": "T", "ACA": "T", "ACG": "T",
		"AAT": "N", "AAC": "N", "AAA": "K", "AAG": "K",
		"AGT": "S", "AGC": "S", "AGA": "R", "AGG": "R",
		"GTT": "V", "GTC": "V", "GTA": "V", "GTG": "V",
		"GCT": "A", "GCC": "A", "GCA": "A", "GCG": "A",
		"GAT": "D", "GAC": "D", "GAA": "E", "GAG": "E",
		"GGT": "G", "GGC": "G", "GGA": "G", "GGG": "G"
	}

	codonMapReplace := {
		"TTT": "F", "TTC": "F", "TTA": "L", "TTG": "L",
		"TCT": "S", "TCC": "S", "TCA": "S", "TCG": "S",
		"TAT": "Y", "TAC": "Y", "TAA": stopReplacement("ochre"),
		"TAG": stopReplacement("amber"), "TGT": "C", "TGC": "C",
		"TGA": stopReplacement("opal"), "TGG": "W",
		"CTT": "L", "CTC": "L", "CTA": "L", "CTG": "L",
		"CCT": "P", "CCC": "P", "CCA": "P", "CCG": "P",
		"CAT": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
		"CGT": "R", "CGC": "R", "CGA": "R", "CGG": "R",
		"ATT": "I", "ATC": "I", "ATA": "I", "ATG": "M",
		"ACT": "T", "ACC": "T", "ACA": "T", "ACG": "T",
		"AAT": "N", "AAC": "N", "AAA": "K", "AAG": "K",
		"AGT": "S", "AGC": "S", "AGA": "R", "AGG": "R",
		"GTT": "V", "GTC": "V", "GTA": "V", "GTG": "V",
		"GCT": "A", "GCC": "A", "GCA": "A", "GCG": "A",
		"GAT": "D", "GAC": "D", "GAA": "E", "GAG": "E",
		"GGT": "G", "GGC": "G", "GGA": "G", "GGG": "G"
	}

	translateNtToAaExpr := func(ntExpr, codonMap) {
		seq := ntExpr.fillNull("").strToUpper()
		seq = seq.strReplace("(.{3})", "$1|", { replaceAll: true })
		for codon, aa in codonMap {
			seq = seq.strReplace(codon + "|", aa + "|", { replaceAll: true, literal: true })
		}
		seq = seq.strReplace("\\|$", "", { replaceAll: false })
		seq = seq.strReplace("|", "", { replaceAll: true, literal: true })
		seq = seq.strReplace("[ACGT]{1,2}$", "", { replaceAll: true })
		return seq
	}

	pairs := []
	for aaCol in aminoAcidSeqColumns {
		ntCol := text.replace(aaCol, "aaSeq", "nSeq", 1)
		pairs = append(pairs, { aa: aaCol, nt: ntCol })
	}

	expressions := []
	replacedAnyExprs := []
	replacedColsExprs := []
	for pair in pairs {
		aaCol := pair.aa
		ntCol := pair.nt
		translatedBase := translateNtToAaExpr(pt.col(ntCol), codonMapBase)
		translatedReplaced := translateNtToAaExpr(pt.col(ntCol), codonMapReplace)
		expressions = append(expressions, translatedReplaced.alias(aaCol))
		cond := translatedReplaced.neq(translatedBase)
		replacedAnyExprs = append(replacedAnyExprs, cond)
		replacedColsExprs = append(replacedColsExprs, pt.when(cond).then(pt.lit(aaCol)).otherwise(pt.lit("")))
	}
	if len(expressions) > 0 {
		df = df.withColumns(expressions...)
	}

	if len(replacedAnyExprs) > 0 {
		colsList := pt.concatStr(replacedColsExprs, { delimiter: "," })
		colsList = colsList.strReplace(",+", ",", { replaceAll: true }).strReplace("^,|,$", "", { replaceAll: true })
		df = df.withColumns(
			pt.anyHorizontal(replacedAnyExprs...).alias("stopCodonReplaced"),
			colsList.alias("stopCodonReplacedColumns")
		)
	}

	stopChecks := []
	for colName in aminoAcidSeqColumns {
		stopChecks = append(stopChecks, pt.col(colName).strContains("*", { literal: true }))
	}
	if len(stopChecks) > 0 {
		df = df.filter(pt.anyHorizontal(stopChecks...).eq(false))
	}

	if !is_undefined(cdr3SeqColumns) && len(cdr3SeqColumns) > 0 {
		regionChecks := []
		for colName in cdr3SeqColumns {
			regionChecks = append(regionChecks, pt.col(colName).strToUpper().eq("REGION_NOT_COVERED"))
		}
		if len(regionChecks) > 0 {
			df = df.filter(pt.anyHorizontal(regionChecks...).eq(false))
		}
	}

	return df
}

self.body(func(inputs) {
	clnsFile := inputs[pConstants.VALUE_FIELD_NAME]

	params := inputs.params
	exportArgs := params.exportArgs

	clonotypeKeyColumns := params.clonotypeKeyColumns
	mainIsProductiveColumn := params.mainIsProductiveColumn
	aminoAcidSeqColumns := params.aminoAcidSeqColumns
	aminoAcidSeqColumnPairs := params.aminoAcidSeqColumnPairs
	cdr3SeqColumns := params.cdr3SeqColumns
	stopCodonTypes := params.stopCodonTypes
	stopCodonReplacements := params.stopCodonReplacements

	useProductiveFilter := is_undefined(stopCodonTypes) || len(stopCodonTypes) == 0

	hashKeyDerivationExpressionPt := func(sourceColumns) {
		return pt.concatStr(
			slices.map(sourceColumns, func(colName) { return pt.col(colName) }),
			{delimiter: "#"}
		).hash("sha256", "base64_alphanumeric", 120)
	}

	createExport := func(additionalAction) {
		mixcrCmdBuilder := exec.builder().
			inMediumQueue().
			mem("12GB").
		    cpu(2).
			printErrStreamToStdout().
			software(mixcrSw).
			secret("MI_LICENSE", "MI_LICENSE").
			env("MI_LICENSE_DEBUG", "MI_LICENSE_DEBUG").
			arg("exportClones").
			arg("--dont-split-files").
			arg("--drop-default-fields").
			arg("--reset-export-clone-table-splitting").
			arg("--chains").arg(params.mixcrChains)

		if useProductiveFilter {
			mixcrCmdBuilder = mixcrCmdBuilder.arg("--export-productive-clones-only")
		} else {
			mixcrCmdBuilder = mixcrCmdBuilder.arg("--filter-out-of-frames")
		}

		additionalAction(mixcrCmdBuilder)

		return mixcrCmdBuilder.
			arg("clones.clns").
			addFile("clones.clns", clnsFile).
			arg("clones.tsv").
			saveFile("clones.tsv").
			addFile("library.json", params.referenceLibrary).
			cacheHours(3).
			run()
	}

	mixcrCmd := createExport(func(mixcrCmdBuilder) {
		for argGrp in exportArgs {
			for arg in argGrp {
				mixcrCmdBuilder.arg(arg)
			}
		}
	})

	unprocessedTsv := mixcrCmd.getFile("clones.tsv")

	if is_undefined(clonotypeKeyColumns) {
		ll.panic("clonotypeKeyColumns is undefined")
	}

	// Simplified PTabler processing for main TSV output
	wfMain := pt.workflow().
		inMediumQueue().
		mem("8GB").
		cpu(2)
		
	frameInputMap := {
		file: unprocessedTsv,
		xsvType: "tsv",
		schema: [ { column: "readCount", type: "Double" } ]
	}
	dfMain := wfMain.frame(frameInputMap, { inferSchema: false, id: "input_table" })

	dfMain.addColumns(
		pt.col("readCount").round().cast("Long").alias("readCount")
	)
	// Normalize isProductive column casing to strictly "true"/"false"
	if !is_undefined(mainIsProductiveColumn) {
		dfMain.addColumns(
			pt.when(pt.col(mainIsProductiveColumn).strToUpper().eq("TRUE")).
				then(pt.lit("true")).
				otherwise(pt.lit("false")).
				alias(mainIsProductiveColumn)
		)
	}
	if !is_undefined(stopCodonTypes) && len(stopCodonTypes) > 0 {
		dfMain = applyStopCodonReplacementsPt(dfMain, {
			aminoAcidSeqColumns: aminoAcidSeqColumns,
			aminoAcidSeqColumnPairs: aminoAcidSeqColumnPairs,
			cdr3SeqColumns: cdr3SeqColumns,
			stopCodonTypes: stopCodonTypes,
			stopCodonReplacements: stopCodonReplacements
		})
	}
	dfMain.addColumns(
		hashKeyDerivationExpressionPt(clonotypeKeyColumns).alias("clonotypeKey")
	)

	// Generate clonotypeLabel (C-XXXXX or C-XXXXX-RANK) from clonotypeKey
	dfMain = clonotypeLabel.addClonotypeLabelColumnsPt(dfMain, "clonotypeKey", "clonotypeLabel", pt)

	dfMain.save("output.tsv")
	ptablerResultMain := wfMain.run()
	processedTsv := ptablerResultMain.getFile("output.tsv")

	return {
		tsv: processedTsv
	}
}) 