// process

self := import("@platforma-sdk/workflow-tengo:tpl")

render := import("@platforma-sdk/workflow-tengo:render")
ll := import("@platforma-sdk/workflow-tengo:ll")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")

math := import("math")
json := import("json")
text := import("text")

mixcrAnalyzeTpl := assets.importTemplate(":mixcr-analyze")
mixcrExportTpl := assets.importTemplate(":mixcr-export")
aggregateByClonotypeKeyTpl := assets.importTemplate(":aggregate-by-clonotype-key")
exportReportTpl := assets.importTemplate(":export-report")
calculateExportSpecs := import(":calculate-export-specs")

self.awaitState("InputsLocked")
self.awaitState("params", "ResourceReady")
self.awaitState("inputSpec", "ResourceReady")
self.awaitState("referenceLibrary", "ResourceReady")
self.awaitState("cdr3Sequences", "ResourceReady")

self.body(func(inputs) {

	inputSpec := inputs.inputSpec
	params := inputs.params
	blockId := params.blockId
	referenceLibrary := inputs.referenceLibrary
	chains := params.chains
	mixcrChains := params.mixcrChains
	cloneClusteringMode := params.cloneClusteringMode
	tagPattern := params.tagPattern

	extractUmiTags := func(pattern) {
		if is_undefined(pattern) || pattern == "" {
			return []
		}
		umiTags := []
		parts := text.split(pattern, "(")
		for idx, part in parts {
			if idx == 0 {
				continue
			}
			if !text.contains(part, ":") {
				continue
			}
			name := text.split(part, ":")[0]
			if !text.has_prefix(text.to_lower(name), "umi") {
				continue
			}
			exists := false
			for tag in umiTags {
				if tag == name {
					exists = true
					break
				}
			}
			if !exists {
				umiTags = append(umiTags, name)
			}
		}
		return umiTags
	}

	umiTags := extractUmiTags(tagPattern)
	hasUMI := len(umiTags) > 0
	limitInput := inputs.limitInput
	perProcessMemGB := params.perProcessMemGB
	perProcessCPUs := params.perProcessCPUs

	// Base memory for scheduling downstream operations, linked to user override
	// with current hardcoded values as floors (see memGB helper below)
	baseMemGB := 64
	if !is_undefined(perProcessMemGB) {
		baseMemGB = perProcessMemGB
	}
	// Returns max(floor, baseMemGB / divisor) as a string like "32GB"
	memGB := func(floorGB, divisor) {
		return string(int(math.max(floorGB, baseMemGB / divisor))) + "GB"
	}

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]
	sampleIdAxisSpec := inputSpec.axesSpec[0]

	// Use calculateExportSpecs for output columns
	presetSpecForBack := {
		assemblingFeature: params.assemblingFeature,
		splitByC: true,
		umiTags: hasUMI ? umiTags : undefined,
		cellTags: []
	}

	exportSpecs := calculateExportSpecs(presetSpecForBack, blockId)

	columnsSpecPerSample := exportSpecs.columnsSpecPerSample
	columnsSpecPerClonotypeNoAggregates := exportSpecs.columnsSpecPerClonotypeNoAggregates
	columnsSpecPerClonotypeAggregates := exportSpecs.columnsSpecPerClonotypeAggregates
	cdr3DistanceColumnsSpec := exportSpecs.cdr3DistanceColumnsSpec
	clonotypeKeyColumns := exportSpecs.clonotypeKeyColumns
	clonotypeKeyArgs := exportSpecs.clonotypeKeyArgs
	exportArgs := exportSpecs.exportArgs
	mainAbundanceColumnNormalized := exportSpecs.mainAbundanceColumnNormalized
	mainAbundanceColumnUnnormalized := exportSpecs.mainAbundanceColumnUnnormalized
	mainIsProductiveColumn := exportSpecs.mainIsProductiveColumn
	productiveFeature := exportSpecs.productiveFeature
	axesByClonotypeKey := exportSpecs.axesByClonotypeKey
	aminoAcidSeqColumns := exportSpecs.aminoAcidSeqColumns
	aminoAcidSeqColumnPairs := exportSpecs.aminoAcidSeqColumnPairs
	cdr3SeqColumns := exportSpecs.cdr3SeqColumns

	columnsToSchema := func(columns) {
		schema := []
		columnsAdded := {}
		for col in columns {
			if !columnsAdded[col.column] {
				schema += [ { column: col.column, type: col.spec.valueType } ]
				columnsAdded[col.column] = true
			}
		}
		return schema
	}


	clnsAnnotations := {
		"mixcr.com/assemblingFeature": params.assemblingFeature,
		"pl7.app/label": "MiXCR Amplicon Alignment Clonesets"
	}

	// Create target outputs
	targetOutputs := [ {
		type: "Resource",
		spec: {
			kind: "PColumn",
			valueType: "File",
			name: "mixcr.com/qc",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			}
		},
		name: "qc"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "pl7.app/log",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "Log"
		},
		name: "log"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/clns",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			annotations: clnsAnnotations,
			valueType: "File"
		},
		name: "clns"
	}, {
		type: "ResourceMap",
		name: "reports",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/report",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "File",
			axesSpec: [ {
				type: "String",
				name: "mixcr.com/report/source",
				annotations: {
					"pl7.app/label": "Source MiXCR stage"
				}
			}, {
				type: "String",
				name: "mixcr.com/report/format",
				annotations: {
					"pl7.app/label": "Report format"
				},
				domain: {
					"pl7.app/dense": string(json.encode(["json", "txt"]))
				}
			} ]
		}
	}]

	// Run MiXCR analysis
	mixcrResults := pframes.processColumn(
		{ spec: inputSpec, data: inputs.inputData },
		mixcrAnalyzeTpl,
		targetOutputs,
		{
			aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/readIndex",
				optional: true
			}],

			passAggregationAxesNames: true,

			traceSteps: [{type: "milaboratories.mixcr-amplicon-alignment", id: blockId, importance: 20, label: "MiXCR generic amplicon"}],

			extra: {
				params: maps.clone({
					fileExtension: fileExtension,
					referenceLibrary: referenceLibrary,
					cloneClusteringMode: cloneClusteringMode,
					hasUMI: hasUMI,
					tagPattern: tagPattern,
					assemblingFeature: params.assemblingFeature,
					badQualityThreshold: params.badQualityThreshold
				}, { removeUndefs: true }),
				limitInput: limitInput
			},

			// by passing those parameters as meta fields we allow for recovery and deduplication mechanisms
			// to pick up the results from executions with different values for CPU and Memory overrides
            metaExtra: {
                perProcessMemGB: perProcessMemGB,
                perProcessCPUs: perProcessCPUs
            }
		}
	)

	axesByClonotypeKeyWithChain := [ maps.deepTransform(axesByClonotypeKey[0], {
			spec: { domain: { "pl7.app/vdj/chain": chains } }
		}) ]

	clonotypeTables := pframes.pFrameBuilder()

	exportOutputs := [ {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/clonotypeTable",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "File"
		},
		name: "clonotypeTable",
		path: ["tsv"]
	}, {
		type: "Xsv",
		xsvType: "tsv",
		settings: {
			axes: axesByClonotypeKeyWithChain,
			columns: columnsSpecPerSample,
			storageFormat: "Parquet",
			partitionKeyLength: 0
		},
		mem: memGB(16, 2),
		cpu: 2,
		name: "byCloneKeyBySample",
		path: ["tsv"]
	}]

	exportResults := pframes.processColumn(
		mixcrResults.output("clns"),
		mixcrExportTpl,
		exportOutputs,
		{
			extra: {
				params: maps.clone({
					clonotypeKeyColumns: clonotypeKeyColumns,
					exportArgs: exportArgs,
					referenceLibrary: referenceLibrary,
					mixcrChains: mixcrChains,
					mainIsProductiveColumn: mainIsProductiveColumn,
					aminoAcidSeqColumns: aminoAcidSeqColumns,
					aminoAcidSeqColumnPairs: aminoAcidSeqColumnPairs,
					cdr3SeqColumns: cdr3SeqColumns,
					stopCodonTypes: params.stopCodonTypes,
					stopCodonReplacements: params.stopCodonReplacements,
					perProcessMemGB: perProcessMemGB
				}, { removeUndefs: true })
			}
		}
	)

	clonotypeTables.add(mixcrChains, exportResults.outputSpec("clonotypeTable"), exportResults.outputData("clonotypeTable"))
	clonotypeTablesData := {}
	clonotypeTablesData[chains] = exportResults.outputData("clonotypeTable")

	// Aggregate by clonotype key
	aggregationOutputs := [ {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/clonotypeProperties",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "File"
		},
		name: "clonotypeProperties",
		path: ["tsv"]
	}, {
		type: "Xsv",
		xsvType: "tsv",
		settings: {
			axes: axesByClonotypeKeyWithChain,
			columns: columnsSpecPerClonotypeNoAggregates + columnsSpecPerClonotypeAggregates,
			storageFormat: "Parquet"
		},
		mem: memGB(12, 4),
		cpu: 2,
		name: "aggregates",
		path: ["tsv"]
	}, {
		type: "Xsv",
		xsvType: "tsv",
		settings: {
			axes: axesByClonotypeKeyWithChain,
			columns: cdr3DistanceColumnsSpec,
			storageFormat: "Parquet"
		},
		mem: memGB(8, 8),
		cpu: 1,
		name: "cdr3Distances",
		path: ["cdr3DistancesTsv"]
	} ]

	aggregationResults := pframes.processColumn(
		exportResults.output("clonotypeTable"),
		aggregateByClonotypeKeyTpl,
		aggregationOutputs,
		{
			aggregate: ["pl7.app/sampleId"],
			traceSteps: [{type: "milaboratories.mixcr-amplicon-alignment.aggregate", id: blockId + "." + chains, importance: 150, label: "Aggregate " + chains}],

			extra: {
				params: {
					mainAbundanceColumnNormalized: mainAbundanceColumnNormalized,
					mainAbundanceColumnUnnormalized: mainAbundanceColumnUnnormalized,
					schemaPerClonotypeNoAggregates: columnsToSchema(columnsSpecPerClonotypeNoAggregates),
					schemaPerClonotypeAggregates: columnsToSchema(columnsSpecPerClonotypeAggregates),
					schemaPerSample: columnsToSchema(columnsSpecPerSample),
					cdr3Sequences: inputs.cdr3Sequences,
					cdr3DistanceColumnsSpec: cdr3DistanceColumnsSpec
				}
			}
		}
	)

	//Build final output
	clones := pframes.pFrameBuilder()
	exportResults.addXsvOutputToBuilder(clones, "byCloneKeyBySample", "clonotypeProperties/bySample/" + chains + "/")
	aggregationResults.addXsvOutputToBuilder(clones, "aggregates", "clonotypeProperties/aggregates/" + chains + "/")
	aggregationResults.addXsvOutputToBuilder(clones, "cdr3Distances", "clonotypeProperties/cdr3Distances/" + chains + "/")

	qcReportTable := render.create(exportReportTpl, {
		clnsData: mixcrResults.outputData("clns"),
		sampleIdAxisSpec: sampleIdAxisSpec,
		chains: [chains],
		library: referenceLibrary,
		isLibraryFileGzipped: false,
		clonotypeTablesData: clonotypeTablesData,
		hasUmi: hasUMI,
		umiTags: umiTags,
		productiveFeature: productiveFeature,
		stopCodonTypes: params.stopCodonTypes,
		stopCodonReplacements: params.stopCodonReplacements
	})

	return {
		"qc.spec": mixcrResults.outputSpec("qc"),
		"qc.data": mixcrResults.outputData("qc"),

		"logs.spec": mixcrResults.outputSpec("log"),
		"logs.data": mixcrResults.outputData("log"),

		"reports.spec": mixcrResults.outputSpec("reports"),
		"reports.data": mixcrResults.outputData("reports"),

		"clns.spec": mixcrResults.outputSpec("clns"),
		"clns.data": mixcrResults.outputData("clns"),

		"progress.data": mixcrResults.outputData("log"),

		clones: clones.build(),
		clonotypeTables: clonotypeTables.build(),
		qcReportTable: qcReportTable.output("qcReportTable")
	}
}) 